## Sample-Splitting:

Try out what happens on your simulated data sets from last week when you use sample splitting!

Given a n x p data set:

-   Randomly split the rows into two equally sized groups.

-   Make one half (n/2) of the rows a new data set (call it the training set) and the other half of the rows (n/2( a new data set (call it the test set).

-   Cluster the rows of the training set to get two clusters, i.e a partition of {1, 2, .... n/2}.

-   We now need to get cluster coordinates for the rows of the test set! Let's try this:

    -   Add up all the rows in the training set that correspond to the first cluster and divide by n/2 to get $\theta_1$

    -   Add up all the rows in the training set that correspond to the second cluster and divide by n/2 to get $\theta_2$

    -   For each row in the testing set, assign it to cluster 1 if it's closer in Euclidean distance to $\theta_1$ than $\theta_2$, and assign it to cluster 2 otherwise. (Note: if you simulated Gaussian data with covariance matrix not proportional to the identity, you might get more sensible looking results if you replace Euclidean distance with Mahalanobis distance.)

        This is different than what's in my paper, but is also something simple that I could imagine someone trying:!

-   Run a two-sample Z-test on the test set to compare the two clusters with respect to the first covariate.


```{r}
library(MASS)

# Define values for the mean vector and the variance covariance matrix, which can be directly used in the dataset_generator function
mu1 = 0
mu2 = 0
sigma11 = 1
sigma12 = 0
sigma22 = 1

dataset_generator <-function(n) {
  mu = c(mu1,mu2)
  sigma = matrix(c(sigma11,sigma12,sigma12,sigma22), nrow = 2, byrow = TRUE)
  
# Generate the covariates Zi1 and Zi2
# When using different means and covariance matrices, define them seperately 
# above and adjust the notation in mvrnorm
  Z = mvrnorm(n, mu, sigma)

  output<-Z
  return(output)
}

# This will generate "datasets", our datasets of interest

set.seed(123)

datapoints_per_set = 1000
total_datasets = 1000
datasets <- replicate(total_datasets, dataset_generator(datapoints_per_set))
head(datasets[, , 1])

```
```{r}
 euclidean.dist <- function(x, y) {
   sqrt(sum((x - y)^2))
 }
``` 
